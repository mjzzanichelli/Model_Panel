<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: kb.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: kb.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileOverview Wiki Text KB
 * @author José Marco Zanichelli
 * @version: 0.1
 */

/**
 * @namespace
 * @description
  &lt;p>kb framework is generated by an anonymous &lt;b>constructor&lt;/b>&lt;/p>
  &lt;p>It can be named differently at any time &lt;/p>
 * @example
 * var kb = (
 * //.............
 *	if (kb) return kb;
 * 
 * //kb renamed to fwk 
 * var fwk = (
 * //.............
 *	if (fwk) return fwk;
 */
var kb = (
	
	/**
     * Creates the kb instance
     * @protected
     * @alias kb.constructor
     * @namespace
     */
	function(kb){
		
		if (kb!==undefined) return kb;
		
		/**
	     * @protected
	     * @alias kb.constructor._self
	     * @namespace
	     * @description Capsule Object for constructor instance.
	     */
		var _self = {};
		
		
		/**
	     * @protected
	     * @alias kb.constructor._private
	     * @namespace 
	     * @description
	     	&lt;p>List of private methods that can be used inside the constructor.&lt;/p>
	     	&lt;p>All properties listed in &lt;b>_private&lt;/b> are only accessible using using &lt;b>_private.&lt;propertyName&gt;&lt;/b> inside kb.constructor&lt;/p>
	     * @property {function} _private.defineProperty - {@link kb.constructor._private.defineProperty (this)} Replaces Object.defineProperty when not supported
	     * @property {function} _private.defineProperties - {@link kb.constructor._private.defineProperties (this)} Replaces Object.defineProperties when not supported
	     * @property {function} _private.getOwnPropertyNames - {@link kb.constructor._private.getOwnPropertyNames (this)} Replaces Object.getOwnPropertyNames when not supported
	     * @property {function} _private.getOwnPropertyDescriptor - {@link kb.constructor._private.getOwnPropertyDescriptor (this)} Replaces Object.getOwnPropertyDescriptor when not supported
	     * @property {function} _private.getKBObjectDefinition - {@link kb.constructor._private.getKBObjectDefinition (this)} Applies default object definition properties
		 * @property {array} _private.iModelPrototype - {@link kb.constructor._private.iModelPrototype (this)} Collection of {@link kb.constructor.iModel Model} Constructor prototype properties
		 * @property {array} _private.iPanelPrototype - {@link kb.constructor._private.iPanelPrototype (this)} Collection of {@link kb.constructor.iPanel Panel} Constructor prototype properties
		 * @property {function} _private.dumpInstance - {@link kb.constructor._private.dumpInstance (this)} Global method to dump {@link kb.constructor.iModel Models} and {@link kb.constructor.iPanel Panels} instances 
		 * @property {function} _private.wrapInstanceMethod - {@link kb.constructor._private.wrapInstanceMethod (this)} Wrapper to avoid prototypical methods of {@link kb.constructor.iModel Models} and {@link kb.constructor.iPanel Panels} instances been called when dumped
	     */
		var _private = {
			
			/**
			 * @method kb.constructor._private.defineProperty
		 	 * @param {object} obj - Object to be redifined
		 	 * @param {string} key - Property inside the object to be redifined
		 	 * @param {object} options - Configuration object to modify the default definition set
		 	 * @returns {object} object to be used with Object.defineProperty 
		 	 * @description 
		 	 &lt;p>When &lt;b>Object.defineProperty&lt;/b> is not fully supported (eg. IE8 and previous), the wrapper simply set a new value for the specified property key in the object destination.&lt;/p> 
		 	 &lt;p>
		 	 	"options" can contain: {@link kb.constructor._private.getKBObjectDefinition (see getKBObjectDefinition)}:
		 	 	&lt;i>
		 	 	&lt;br>{
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;b>configurable:&lt;/b> false
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;, &lt;b>enumerable:&lt;/b> true
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;, &lt;b>writable:&lt;/b> false
		 	 	&lt;br>}
		 	 	&lt;/i>
		 	 &lt;/p>
		 	 * @example var obj = _private.defineProperty(obj,"property",_private.getKBObjectDefinition("property_value"))
		 	 * //obj["property"] value: {configurable: false, enumerable: true, writable: false, value: "property_value"}
		 	 * 
		 	 * @example var obj = _private.defineProperty(obj,"property",_private.getKBObjectDefinition("property_value",{configurable: true}))
		 	 * //obj["property"] value: {configurable: true, enumerable: true, writable: false, value: "property_value"}
		 	 */
		 	defineProperty: (function(){
		 		var _defineProperty;
				try{
					Object.defineProperty({},"x",{});
					_defineProperty = function(obj,key,options){
						Object.defineProperty(obj,key,options);
						return obj;
					};
				} catch(e){
					_defineProperty = function(obj,key,options){
						options = options || {};
						obj[key] = options.value || null;
						return obj;
					};
				}
		 		return _defineProperty;
		 	})()
		 	
		 	/**
			 * @method kb.constructor._private.defineProperties
		 	 * @param {object} obj - Object to be redifined
		 	 * @param {object} props - Property inside the object to be redifined
		 	 * @returns {object} object to be used with Object.defineProperty 
		 	 * @description 
		 	 &lt;p>When &lt;b>Object.defineProperties&lt;/b> is not fully supported (eg. IE8 and previous), the wrapper simply set new values for the specified property keys in the object destination.&lt;/p> 
		 	 &lt;p>
		 	 	&lt;b>options&lt;/b> must be defined inside &lt;b>props&lt;/b>, they can contain {@link kb.constructor._private.getKBObjectDefinition (getKBObjectDefinition)}:
		 	 	&lt;i>
		 	 	&lt;br>{
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;b>configurable:&lt;/b> false
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;, &lt;b>enumerable:&lt;/b> true
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;, &lt;b>writable:&lt;/b> false
		 	 	&lt;br>}
		 	 	&lt;/i>
		 	 &lt;/p>
		 	 * @example var obj = _private.defineProperties(obj,{"property":_private.getKBObjectDefinition("property_value")},)
		 	 * //obj["property"] value: {configurable: false, enumerable: true, writable: false, value: "property_value"}
		 	 * 
		 	 * @example var obj = _private.defineProperties(obj,{"property":_private.getKBObjectDefinition("property_value",{configurable: true})})
		 	 * //obj["property"] value: {configurable: true, enumerable: true, writable: false, value: "property_value"}
		 	 */
		 	, defineProperties: (function(){
		 		var _defineProperties;
				try{
					Object.defineProperties({},{"x":{}});
					_defineProperties = function(obj,props){
						Object.defineProperties(obj,props);
						return obj;
					};
				} catch(e){
					_defineProperties = function(obj,props){
						props = props || {};
						for (var p in props){
							obj[p] = props[p].value || null;
						}
						return obj;
					};
				}
		 		return _defineProperties;
		 	})()
		 	
		 	/**
			 * @method kb.constructor._private.getOwnPropertyNames
		 	 * @param {object} obj - Object to extract own properties from
		 	 * @returns {array} list of obect's owned properties  
		 	 * @description 
		 	 &lt;p>When &lt;b>Object.getOwnPropertyNames&lt;/b> is not fully supported (eg. IE8 and previous), the wrapper loop through an object properties returning those NOT inherited by prototype (own properties).&lt;/p>
		 	 * @example var props = _private.getOwnPropertyNames({x:"something"})
		 	 * //props value: ["x"]
		 	 */
		 	, getOwnPropertyNames: (function(){
				var _getOwnPropertyNames;
				try{
					Object.getOwnPropertyNames({});
					_getOwnPropertyNames = function(obj){
						return Object.getOwnPropertyNames(obj);
					};
				} catch(e){
					_getOwnPropertyNames = function(obj){
						var names = [];
						for (var k in obj)if (obj.hasOwnProperty(k))names.push(k);
						return names; 
					};
				}
		 		return _getOwnPropertyNames;
		 	})()
		 	
		 	/**
			 * @method kb.constructor._private.getOwnPropertyDescriptor
		 	 * @param {object} obj - Object to extract property the definition from
		 	 * @param {string} key - Key name of the property to extract the definition from
		 	 * @returns {object} Definition object for a property in an object   
		 	 * @description 
		 	 &lt;p>When &lt;b>Object.getOwnPropertyDescriptor&lt;/b> is not fully supported (eg. IE8 and previous), the wrapper returns the default configuration object from {@link kb.constructor._private.getKBObjectDefinition _private.getKBObjectDefinition} and its value extended.&lt;/p>
		 	 &lt;p>When &lt;b>Object.getOwnPropertyDescriptor&lt;/b> is not fully supported (eg. IE8 and previous), the wrapper returns undefined if the property doesn't exsits in the object.&lt;/p>
		 	 * @example var props = _private.getOwnPropertyDescriptor({x:"something"},"x")
		 	 * //props value: {value: "something", writable: false, enumerable: true, configurable: false}
		 	 * 
		 	 * var props = _private.getOwnPropertyDescriptor({x:"something"},"y")
		 	 * //props value: undefined
		 	 */
		 	, getOwnPropertyDescriptor: (function(){
		 		var _getOwnPropertyDescriptor;
				try{
					Object.getOwnPropertyDescriptor({x:null},"x");
					_getOwnPropertyDescriptor = function(obj,key){
						return Object.getOwnPropertyDescriptor(obj,key);
					};
				} catch(e){
					_getOwnPropertyDescriptor = function(obj,key){
						if (obj[key]==undefined) return undefined;
						return _private.getKBObjectDefinition(obj[key]);
					};
				}
		 		return _getOwnPropertyDescriptor;
		 	})()
			
			/**
			 * @method kb.constructor._private.getKBObjectDefinition
		 	 * @param {any} value - Default value for the new property
		 	 * @param {object} [extension] - Configuration object to modify the default definition set
		 	 * @returns {object} Configuration object to be used with Object.defineProperty 
		 	 * @description 
		 	 &lt;p>Applies default object definition properties.&lt;/p> 
		 	 &lt;p>
		 	 	When argument "extension" is not declared, default is applied to the returning value:
		 	 	&lt;i>
		 	 	&lt;br>{
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;b>configurable:&lt;/b> false
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;, &lt;b>enumerable:&lt;/b> true
		 	 		&lt;br>&nbsp;&nbsp;&nbsp;&nbsp;, &lt;b>writable:&lt;/b> false
		 	 	&lt;br>}
		 	 	&lt;/i>
		 	 &lt;/p>
		 	 * @example var property = _private.getKBObjectDefinition("property_value")
		 	 * //property value: {configurable: false, enumerable: true, writable: false, value: "property_value"}
		 	 * 
		 	 * var property = _private.getKBObjectDefinition("property_value",{configurable: true})
		 	 * //property value: {configurable: true, enumerable: true, writable: false, value: "property_value"}
		 	 */
		 	, getKBObjectDefinition: function(value,extension){
				var _props = {
					configurable: false
					, enumerable: true
					, writable: false
					, value: value
				};
				_props = _public.extend(_props,extension);
				return _props;
			}
			
			/**
			 * @member {String[]} kb.constructor._private.iModelPrototype
			 * @description 
			 	&lt;p>Collection of {@link kb.constructor.iModel Model} Constructor prototype properties.&lt;/p>
			 	&lt;p>Used to match Model's extension names against the Model's native methods and properties.&lt;/p>    
		 	 */
			, iModelPrototype: []
			
			/**
			 * @member {String[]} kb.constructor._private.iPanelPrototype
			 * @description
			 	&lt;p>Collection of {@link kb.constructor.iPanel Panel} Constructor prototype properties.&lt;/p>
			 	&lt;p>Used to match Panel's extension names against the Panel's native methods and properties.&lt;/p>
		 	 */
			, iPanelPrototype: []
			
			/**
			 * @method kb.constructor._private.dumpInstance
		 	 * @returns {undefined} When dumping a Panel, all referenced Models instances get dumped too 
		 	 * @description 
		 	 &lt;p>
		 	 	When a Model or Panel instance calls the method &lt;b>dump()&lt;/b>, it will effectively 
		 	 	&lt;br>fire the global method &lt;b>_private.dumpInstance()&lt;/b> wrapped inside &lt;b>_private.wrapInstanceMethod&lt;/b>
		 	 &lt;/p>
		 	 * @example var obj = new Model("model")
		 	 * obj = obj.dump();
		 	 * //obj.dump actually executes _private.wrapInstanceMethod(_private.dumpInstance())
		 	 * //obj is now undefined
		 	 */
			, dumpInstance: function(){
				var _dumper = function(type){
					var _obj = this.constructor.objects[this.type]
						, _inst = _obj.inst;
					;

					delete _obj.inst[this.index];
					if (this.models) for (name in this.models) this.models[name].dump(type);

					if (type==undefined || type=="max"){
						for (i in _obj.prototype) _private.defineProperty(this,i,{configurable:false,enumerable:false,writable:false,value: null});
						for (i in this.constructor.prototype) _private.defineProperty(this,i,{configurable:false,enumerable:false,writable:false,value: null});
					}

					if (type=="min" || type=="max"){
						var _props = _private.getOwnPropertyNames(this);
						i =  _props.length;
						//while(i--) delete this[_props[i]];
						while(i--) {
							//console.log(_props[i],_private.getOwnPropertyDescriptor(this,_props[i]))
							_private.defineProperty(this,_props[i],_public.extend(_private.getOwnPropertyDescriptor(this,_props[i]),{configurable:false,enumerable:false,writable:false,value: null},true));
						}
					}
					
					_private.defineProperty(this,"dumped",{
						configurable: false
						, enumerable: true
						, writable: false
						, value: true
					});
					
					return undefined;
				};
				return _dumper;
			}
			
			/**
			 * @method kb.constructor._private.wrapInstanceMethod
		 	 * @param {function} method - function to be exectued
		 	 * @param {string} [message] - Alternative exception message 
		 	 * @returns {function} When &lt;b>dumped&lt;/b>!=&lt;i>true&lt;/i> it returns instance method executed, otherwise throws an exception
		 	 * @this Model.instance||Panel.instance
		 	 * @description 
		 	 &lt;p>
		 	 	Prevents dumped instances of Models and Panels to call any native methods.    
		 	 	&lt;br>In order to verify the instance status, it check against its property &lt;b>dumped&lt;/b>&lt;/b>
		 	 &lt;/p>
		 	 * @example
			 * var fn = function(){}
			 * fn = _private.wrapInstanceMethod(fn);
			 * //fn will now check for a property fn.dumped not been true to execute
			 * //otherwise it will fire the default error message "Object instance has been dumped"
			 *   
			 * var fn = function(){}
			 * fn = _private.wrapInstanceMethod(fn,"my custom error");
			 * //fn will now check for a property fn.dumped not been true to execute
			 * //otherwise it will fire an error message "my custom error"
		 	 */
			, wrapInstanceMethod: function(method,message){
				message = message || "Object instance has been dumped";
				var _wrapper = function(){
					if (!this.dumped) return method.apply(this,arguments);
					else throw new Error(message);
				};
				return _wrapper;
			}
		};
		
		/**
	     * @public
	     * @alias kb.constructor._public
	     * @namespace
	     * @description
	     	&lt;p>List of public methods to be attached to capsule {@link kb.constructor._self _self} in the {@link kb.constructor constructor}.&lt;/p>
	     	&lt;p>All properties listed in &lt;b>_public&lt;/b> are accessible using &lt;b>kb.&lt;propertyName&gt;&lt;/b> from outside kb.constructor or inside kb.constructor using &lt;b>_public.&lt;propertyName&gt;.&lt;/b>&lt;/p>
	     * @property {function} _public.clone||kb.clone - {@link kb.constructor._public.clone (this)} Creates a copy of literal objects and array. No Model's or Panel's instance clones are allowed.
		 * @property {function} _public.extend||kb.extend - {@link kb.constructor._public.extend (this)} Extend literal objects
		 * @property {array} _public.stringify||kb.stringify - {@link kb.constructor._public.stringify (this)} Returns string representations for literal objects and arrays 
		 * @property {array} _public.type||kb.type - {@link kb.constructor._public.type (this)} Returns the type of a var
		 * @property {function} _public.setModel||kb.setModel - {@link kb.constructor._public.setModel (this)} Creates a Model constructor
		 * @property {function} _public.getModel||kb.getModel - {@link kb.constructor._public.getModel (this)} Returns the list of Models or a specific Model constructor
		 * @property {function} _public.extendModel||kb.extendModel - {@link kb.constructor._public.extendModel (this)} Attaches new methods and properties onto a Model constructor
		 * @property {function} _public.unextendModel||kb.unextendModel - {@link kb.constructor._public.unextendModel (this)} Removes attached methods and properties from a Model constructor
		 * @property {function} _public.stopModel||kb.stopModel - {@link kb.constructor._public.stopModel (this)} Kills Model constructors references inside kb 
		 * @property {function} _public.setPanel||kb.setPanel - {@link kb.constructor._public.setPanel (this)} Creates a Panel constructor
		 * @property {function} _public.getPanel||kb.getPanel - {@link kb.constructor._public.getPanel (this)}Returns the list of Panels or a specific Panel constructor
		 * @property {function} _public.extendPanel||kb.extendPanel - {@link kb.constructor._public.extendPanel (this)}Attaches new methods and properties onto a Panel constructor
		 * @property {function} _public.unextendPanel||kb.unextendPanel - {@link kb.constructor._public.unextendPanel (this)}Removes attached methods and properties from a Panel constructor
		 * @property {function} _public.stopPanel||kb.stopPanel - {@link kb.constructor._public.stopPanel (this)}Kills Model constructors references inside kb 
	     */
		var _public = {
			
			/**
			 * @method kb.constructor._public.clone
		 	 * @param {object|array} obj - base object to copy from
		 	 * @returns {object|array} 
		 	 * @description 
		 	 &lt;p>
		 	 	A new object is generated from using the constructor of obj.
		 	 	&lt;br>Base objects such as Models and Panels, that have properties defined as &lt;i>&lt;b>configurable&lt;/b>=false&lt;/i>, cannot be cloned.&lt;/b>
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = _public.clone(obj);
		 	 * //obj && newobj will be identical
		 	 * var arr = ["item"]
		 	 * var newarr = _public.clone(arr);
		 	 * //arr && newarr will be identical
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = kb.clone("obj");
		 	 * //obj && newobj will be identical
		 	 * var arr = ["item"]
		 	 * var newarr = kb.clone(arr);
		 	 * //arr && newarr will be identical
		 	 */
			clone: function(obj){
			    if(obj == null || typeof(obj) != 'object') return obj;
			    var temp = obj.constructor(); // changed
			    for(var key in obj) temp[key] = _public.clone(obj[key]);
			    return temp;
			}
			
			/**
			 * @method kb.constructor._public.extend
		 	 * @param {object} base - literal object to be extend
		 	 * @param {object} add - new keys to be added to the base 
		 	 * @param {boolean} [overwrite] - resolves merging of identical keys
		 	 * @returns {object} 
		 	 * @description 
		 	 &lt;p>
		 	 	A new object is generated adding &lt;b>add&lt;/b> keys to exting &lt;b>base&lt;/b> keys.  
		 	 	&lt;br>When a key in &lt;b>add&lt;/b> already exsits in &lt;b>base&lt;/b>, it overwrites the origin if &lt;i>&lt;b>overwrite&lt;/b>=true&lt;/i>&lt;/b>
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var _obj = _public.extend(obj,{"newprop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value", "newprop":"newvalue"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = _public.extend(obj,{"prop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = _public.extend(obj,{"prop":"newvalue"},true);
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"newvalue"}
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var _obj = kb.extend(obj,{"newprop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value", "newprop":"newvalue"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = kb.extend(obj,{"prop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = kb.extend(obj,{"prop":"newvalue"},true);
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"newvalue"}
		 	 */
			, extend: function(base,add,overwrite){
				overwrite = overwrite || false;
	            var _extend = {},key;
	            for (key in base) _extend[key] = base[key];
	            for (key in add) if (overwrite || !base[key])_extend[key] = add[key];
	            return _extend;
	        }
	        
	        /**
			 * @method kb.constructor._public.stringify
		 	 * @param {object|array} obj - object to get the string from
		 	 * @returns {string} 
		 	 * @description 
		 	 &lt;p>
		 	 	Given a literal object or array, it returns its string representation.  
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = new Object();
		 	 * obj.prop = "value"
		 	 * var objstring = _public.stringify(obj);
		 	 * //objstring value: "{'prop':'value'}"
		 	 * var arr = new Array();
		 	 * arr.push("item")
		 	 * var arrstring = _public.stringify(arr);
		 	 * //arrstring value: "['item']"
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = new Object();
		 	 * obj.prop = "value"
		 	 * var objstring = kb.stringify(obj);
		 	 * //objstring value: "{'prop':'value'}"
		 	 * var arr = new Array();
		 	 * arr.push("item")
		 	 * var arrstring = kb.stringify(arr);
		 	 * //arrstring value: "['item']"
		 	 */
	        , stringify: function(obj){
	            var t = typeof (obj);
	            if (t != "object" || obj === null) {
	                // simple data type
	                if (t == "string") obj = '"'+obj+'"';
	                return String(obj);
	            }
	            else {
	                // recurse array or object
	                var n, v, json = [], arr = (obj && obj.constructor == Array);
	                for (n in obj) {
	                    v = obj[n]; t = typeof(v);
	                    //if (t == "string") v = '"'+v.replace(/\"/gi,'%22')+'"';
	                    if (t == "string") v = '"'+v+'"';
	                    else if (t == "object" && v !== null) v = this.stringify(v);
	                    json.push((arr ? "" : '"' + n + '":') + String(v));
	                }
	                return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
	            }
	        }
	        
	        /**
			 * @method kb.constructor._public.type
		 	 * @param {any} object - unknown object to identify
		 	 * @returns {string} Given an unknown object, it returns its type in a string 
		 	 * @description 
		 	 &lt;p>
		 	 	Currently recognizing the following types:
		 	 	&lt;ul>
		 	 		&lt;li>&lt;b>null&lt;/b>&lt;/li>
		 	 		&lt;li>&lt;b>undefined&lt;/b>&lt;/li>
		 	 		&lt;li>&lt;b>string&lt;/b>&lt;/li>
		 	 		&lt;li>&lt;b>array&lt;/b>&lt;/li>
		 	 		&lt;li>&lt;b>object&lt;/b>&lt;/li>
		 	 		&lt;li>&lt;b>function&lt;/b>&lt;/li>
		 	 		&lt;li>&lt;b>html&lt;/b>&lt;/li>
		 	 	&lt;/ul>
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = function(){return "I'm a string"};
		 	 * var objtype = _public.type(obj);
		 	 * //objtype value: "function"
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = function(){return "I'm a string"};
		 	 * var objtype = kb.type(obj);
		 	 * //objtype value: "function"
		 	 */
	        , type : function(object){
	            var _stringConstructor = "".constructor
	            , _arrayConstructor = [].constructor
	            , _objectConstructor = {}.constructor
	            , _functionConstructor = function(){}.constructor
	            , _type = "";
	
	            if (object === null) {
	                _type = "null";
	            }
	            else if (object === undefined) {
	                _type = "undefined";
	            }
	            else if (object.constructor === _stringConstructor) {
	                _type = "string";
	            }
	            else if (object.constructor === _arrayConstructor) {
	                _type = "array";
	            }
	            else if (object.constructor === _objectConstructor) {
	                _type = "object";
	            }
	            else if (object.constructor === _functionConstructor) {
	                _type = "function";
	            }
	            else if (object.nodeType !== undefined) {
	                _type = "html";
	            }
	            _stringConstructor = _arrayConstructor =  _objectConstructor = null;
	            return _type;
	        }
	        
	        /**
			 * @method kb.constructor._public.setModel
		 	 * @param {string} mType - Model constructor identifier
		 	 * @param {object} [extension] - Additional set of properties and method to be attached
		 	 * @returns {iModel} A new iModel constructor &lt;b>function&lt;/b> is generated and referenced inside &lt;b>kb&lt;/b> 
		 	 * @description 
		 	 &lt;p>
		 	 	When a new Model constructor is generated, it can be retrieved using &lt;b>kb&lt;/b> and &lt;b>_public&lt;/b>
		 	 	&lt;br/>&lt;i>&lt;b>getModel(&lt;/b>modelType&lt;b>)&lt;/b>&lt;/i> 
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var objmodel = _public.setModel("model",{"fn":function(){}});
		 	 * //objmodel is a new Model constructor
		 	 * var objmodelinst = new objmodel();
		 	 * //objmodelinst is an instance objmodel and inherits all methods, properties and extensions.
		 	 * var check = (objmodel===_public.getModel("model"));
		 	 * //check value: true
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var objmodel = kb.setModel("model",{"fn":function(){}});
		 	 * //objmodel is a new Model constructor
		 	 * var objmodelinst = new objmodel();
		 	 * //objmodelinst is an instance objmodel and inherits all methods, properties and extensions.
		 	 * var check = (objmodel===kb.getModel("model"));
		 	 * //check value: true
		 	 */
			, setModel: function(mType,extension){
				if (_public.type(mType) != "string" && _public.getModel(mType)!== undefined) return undefined;
				var _OM = new iModel(mType,extension);
				return _OM;
			}
			
			/**
			 * @method kb.constructor._public.getModel
		 	 * @param {string} [name] - Model type
		 	 * @returns {array|iModel} When &lt;b>name&lt;/b> is specified it returns the specified Model constructor, otherwise a list of all active Model contructors   
		 	 * @description 
		 	 &lt;p>
		 	 	Retrieves active Model constructors
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setModel("model1");_public.setModel("model2")
		 	 * var models = _public.getModel();
		 	 * //models value: [iModel&lt;model1&gt;, iModel&lt;model2&gt;]
		 	 * var model = _public.getModel("model1");
		 	 * //model value: iModel&lt;model1&gt;
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setModel("model1");kb.setModel("model2")
		 	 * var models = kb.getModel();
		 	 * //models value: [iModel&lt;model1&gt;, iModel&lt;model2&gt;]
		 	 * var model = kb.getModel("model1");
		 	 * //model value: iModel&lt;model1&gt;
		 	 */
			, getModel: function(name){
				return name ? iModel.objects[name] : iModel.objects;
			}
			
			/**
			 * @method kb.constructor._public.extendModel
		 	 * @param {string} name - Model type
		 	 * @param {object} extension - Set of properties and method to extend onto a Model contructor
		 	 * @returns {iModel} &lt;i>&lt;b>False&lt;/b>&lt;/i> is returned if the &lt;b>name&lt;/b> doesn't match any Model constructor, or &lt;b>extension&lt;/b> is not a valid object   
		 	 * @description 
		 	 &lt;p>
		 	 	Attached exstensiones can be overwritten, but only calling &lt;b>extendModel()&lt;/b> a second time 
		 	 	&lt;br/>or redifining the constructor object property: &lt;i>&lt;b>_private.defineProperty(Model,"extension",definingProperties)&lt;/b>&lt;/i>.
		 	 	&lt;br/>&lt;br/>Native methods contained in list &lt;b>_private.iModelPrototype&lt;/b> cannot be overwritten.
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setModel("model1");
		 	 * var model = _public.extendModel("model1",{"fn":function(){}});
		 	 * //model is iModel&lt;model1&gt; with added method model.fn 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setModel("model1");
		 	 * var model = kb.extendModel("model1",{"fn":function(){}});
		 	 * //model is iModel&lt;model1&gt; with added method model.fn
		 	 */
			, extendModel: function(name,extension){
				if (_public.type(name) != "string" || iModel.objects[name]===undefined || _public.type(extension) != "object") return false;
				var _model_proto = [""].concat(_private.iModelPrototype).concat([""]).join();
				for (prop in extension) if (_model_proto.indexOf(","+prop+",")&lt;0) _private.defineProperty(iModel.objects[name].prototype,prop,_private.getKBObjectDefinition(extension[prop],{configurable:true}));
				return iModel.objects[name];
			}
			
			/**
			 * @method kb.constructor._public.unextendModel
		 	 * @param {string} name - Model type
		 	 * @param {string} extension - Model extension name
		 	 * @returns {iModel} &lt;i>&lt;b>False&lt;/b>&lt;/i> is returned if the &lt;b>name&lt;/b> doesn't match any Model constructor, or &lt;b>extension&lt;/b> is not a valid string or a method in &lt;b>iModelPrototype&lt;/b>  
		 	 * @description 
		 	 &lt;p>
		 	 	Only methods and properties that have been previuosly attached onto a Model calling &lt;b>extendModel()&lt;/b> can be unextended. 
		 	 	&lt;br/>&lt;br/>Native methods contained in list &lt;b>_private.iModelPrototype&lt;/b> cannot be unextended.
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setModel("model1");
		 	 * _public.extendModel("model1",{"fn":function(){},"prop":"value"});
		 	 * var model = _public.unextendModel("model1","fn");
		 	 * //model is iModel&lt;model1&gt; with added method model.prop only 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setModel("model1");
		 	 * kb.extendModel("model1",{"fn":function(){},"prop":"value"});
		 	 * var model = kb.unextendModel("model1","fn");
		 	 * //model is iModel&lt;model1&gt; with added method model.prop only
		 	 */
			, unextendModel: function(name,extension){
				if (_public.type(name) != "string" || iModel.objects[name]===undefined || _public.type(extension) != "string" || [""].concat(_private.iModelPrototype).concat([""]).join().indexOf(","+extension+",") >= 0) return false;
				delete iModel.objects[name].prototype[extension];
				return iModel.objects[name];
			}
			
			/**
			 * @method kb.constructor._public.stopModel
		 	 * @param {string} name - Model type
		 	 * @param {boolean} [clean] - Option for cleaning Model instances
		 	 * @param {string} [dump] - Option for dumping Model instances when cleaning
		 	 * @returns {boolean} &lt;i>&lt;b>True&lt;/b>&lt;/i> is returned if cleaning happened successfully, &lt;i>&lt;b>False&lt;/b>&lt;/i> if &lt;b>name&lt;/b> is not a string od doesn't match any existing Model constructor 
		 	 * @description 
		 	 &lt;p>
		 	 	Stopping a Model contructor, its reference in kb gets removed.
		 	 	&lt;br/>When passing &lt;b>clean=&lt;i>true&lt;/i>&lt;/b>, all the Model's instances are dumped. 
		 	 	&lt;br/>When cleaning the Model's instances, the &lt;b>dump&lt;/b> parameter defines how to access the &lt;b>&lt;i>instance.dump()&lt;/i>&lt;/b>:
		 	 	&lt;ul>
		 	 		&lt;li>&lt;b>&lt;undefined&gt;&lt;/b>||&lt;b>"max"&lt;string&gt;&lt;/b> - sets all instances methods and properties to null&lt;/li>
		 	 		&lt;li>&lt;b>"min"&lt;string&gt;&lt;/b> - sets instances property list to null and returns an exception for all methods when called&lt;/li>
		 	 		&lt;li>&lt;b>&lt;others&gt;&lt;/b> - only returns an exception for all methods when called&lt;/li>
		 	 	&lt;/ul>
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var model = _public.setModel("model1");
		 	 * var obj = new model();
		 	 * _public.stop("model1");
		 	 * //model is removed from kb, but obj is not dumped 
		 	 * var model = _public.setModel("model1",true);
		 	 * var obj = new model();
		 	 * _public.stop("model1");
		 	 * //model is removed from kb, and obj is dumped
		 	 * var model = _public.setModel("model1",true,"min");
		 	 * var obj = new model();
		 	 * _public.stop("model1");
		 	 * //model is removed from kb, and obj is dumped in "min" mode
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var model = kb.setModel("model1");
		 	 * var obj = new model();
		 	 * kb.stop("model1");
		 	 * //model is removed from kb, but obj is not dumped 
		 	 * var model = kb.setModel("model1",true);
		 	 * var obj = new model();
		 	 * kb.stop("model1");
		 	 * //model is removed from kb, and obj is dumped
		 	 * var model = kb.setModel("model1",true,"min");
		 	 * var obj = new model();
		 	 * kb.stop("model1");
		 	 * //model is removed from kb, and obj is dumped in "min" mode
		 	 */
			, stopModel: function(name,clean,dump){
				if (_public.type(name) != "string" || iModel.objects[name]===undefined) return false;
				if (clean) for (var i in iModel.objects[name].inst) iModel.objects[name].inst[i].dump(dump);
				var _objects = _public.clone(iModel.objects);
				delete _objects[name];
				_private.defineProperty(iModel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				return true;
			}
			
			/**
			 * @method kb.constructor._public.setPanel
		 	 * @param {string} pType - Panel constructor identifier
		 	 * @param {array} [models] - List of Models constructor to be included
		 	 * @param {object} [extension] - Additional set of properties and method to be attached
		 	 * @returns {iPanel} A new iPanel constructor &lt;b>function&lt;/b> is generated and referenced inside &lt;b>kb&lt;/b> 
		 	 * @description 
		 	 &lt;p>
		 	 	When a new Panel constructor is generated, it can be retrieved using &lt;b>kb&lt;/b> and &lt;b>_public&lt;/b>
		 	 	&lt;br/>&lt;i>&lt;b>getPanel(&lt;/b>panelType&lt;b>)&lt;/b>&lt;/i> 
		 	 	&lt;br/>Passing &lt;b>models&lt;/b>, an instance for each Model will be created for each instance of the Panel constructor 
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var objpanel = _public.setPanel("panel",[],{"fn":function(){}});
		 	 * //objpanel is a new Panel constructor
		 	 * var objPanelinst = new objpanel();
		 	 * //objpanelinst is an instance objpanel and inherits all methods, properties and extensions.
		 	 * var check = (objpanel===_public.getPanel("panel"));
		 	 * //check value: true
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var objpanel = kb.setPanel("panel",[],{"fn":function(){}});
		 	 * //objpanel is a new Panel constructor
		 	 * var objPanelinst = new objpanel();
		 	 * //objpanelinst is an instance objpanel and inherits all methods, properties and extensions.
		 	 * var check = (objpanel===kb.getPanel("panel"));
		 	 * //check value: true
		 	 */
			, setPanel: function(pType,models,extension){
				if (_public.type(pType) != "string" && _public.getPanel(pType)!== undefined ) return undefined;
				var _OP = new iPanel(pType,models,extension);
				return _OP;
			}
			
			/**
			 * @method kb.constructor._public.getPanel
		 	 * @param {string} [name] - Panel type
		 	 * @returns {array|iPanel} When &lt;b>name&lt;/b> is specified it returns the specified Panel constructor, otherwise a list of all active Panel contructors
		 	 * @description 
		 	 &lt;p>
		 	 	Retrieves active Panel constructors
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setPanel("panel1");_public.setPanel("panel2")
		 	 * var panels = _public.getPanel();
		 	 * //panels value: [iPanel&lt;panel1&gt;, iPanel&lt;panel2&gt;]
		 	 * var panel = _public.getPanel("panel1");
		 	 * //panel value: iPanel&lt;panel1&gt;
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setPanel("panel1");kb.setPanel("panel2")
		 	 * var panels = kb.getPanel();
		 	 * //panels value: [iPanel&lt;panel1&gt;, iPanel&lt;panel2&gt;]
		 	 * var panel = kb.getPanel("panel1");
		 	 * //panel value: iPanel&lt;panel1&gt;
		 	 */
			, getPanel: function(name){
				return name ? iPanel.objects[name] : iPanel.objects;
			}
			
			/**
			 * @method kb.constructor._public.extendPanel
		 	 * @param {string} name - Panel type
		 	 * @param {object} extension - Set of properties and method to extend onto a Panel contructor
		 	 * @returns {iPanel} &lt;i>&lt;b>False&lt;/b>&lt;/i> is returned if the &lt;b>name&lt;/b> doesn't match any Panel constructor, or &lt;b>extension&lt;/b> is not a valid object   
		 	 * @description 
		 	 &lt;p>
		 	 	Attached exstensiones can be overwritten, but only calling &lt;b>extendPanel()&lt;/b> a second time 
		 	 	&lt;br/>or redifining the constructor object property: &lt;i>&lt;b>_private.defineProperty(Panel,"extension",definingProperties)&lt;/b>&lt;/i>.
		 	 	&lt;br/>&lt;br/>Native methods contained in list &lt;b>_private.iPanelPrototype&lt;/b> cannot be overwritten.
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setPanel("panel1");
		 	 * var panel = _public.extendPanel("panel1",{"fn":function(){}});
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.fn 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setPanel("panel1");
		 	 * var panel = kb.extendPanel("panel1",{"fn":function(){}});
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.fn
		 	 */
			, extendPanel: function(name,extension){
				if (_public.type(name) != "string" || iPanel.objects[name]===undefined || _public.type(extension) != "object") return false;
				var _panel_proto = [""].concat(_private.iPanelPrototype).concat([""]).join();
				for (prop in extension) {
					if (_panel_proto.indexOf(","+prop+",")&lt;0) {
						_private.defineProperty(iPanel.objects[name].prototype,prop,_private.getKBObjectDefinition(extension[prop],{configurable:true}));
					}
				}
				return iPanel.objects[name],"test";
			}
			
			/**
			 * @method kb.constructor._public.unextendPanel
		 	 * @param {string} name - Panel type
		 	 * @param {string} extension - Panel extension name
		 	 * @returns {iPanel} &lt;i>&lt;b>False&lt;/b>&lt;/i> is returned if the &lt;b>name&lt;/b> doesn't match any Panel constructor, or &lt;b>extension&lt;/b> is not a valid string or a method in &lt;b>iPanelPrototype&lt;/b>  
		 	 * @description 
		 	 &lt;p>
		 	 	Only methods and properties that have been previuosly attached onto a Model calling &lt;b>extendPanel()&lt;/b> can be unextended. 
		 	 	&lt;br/>&lt;br/>Native methods contained in list &lt;b>_private.iPanelPrototype&lt;/b> cannot be unextended.
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setPanel("panel1");
		 	 * _public.extendPanel("panel1",{"fn":function(){},"prop":"value"});
		 	 * var panel = _public.unextendPanel("panel1","fn");
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.prop only 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setPanel("panel1");
		 	 * kb.extendPanel("panel1",{"fn":function(){},"prop":"value"});
		 	 * var panel = kb.unextendPanel("panel1","fn");
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.prop only
		 	 */
			, unextendPanel: function(name,extension){
				if (_public.type(name) != "string" || iPanel.objects[name]===undefined || _public.type(extension) != "string" || [""].concat(_private.iPanelPrototype).concat([""]).join().indexOf(","+extension+",") >= 0) return false;
				delete iPanel.objects[name].prototype[extension];
				return iPanel.objects[name];
			}
			
			/**
			 * @method kb.constructor._public.stopPanel
		 	 * @param {string} name - Panel type
		 	 * @param {boolean} [clean] - Option for cleaning Panel instances
		 	 * @param {string} [dump] - Option for dumping Panel instances when cleaning
		 	 * @returns {boolean} &lt;i>&lt;b>True&lt;/b>&lt;/i> is returned if cleaning happened successfully, &lt;i>&lt;b>False&lt;/b>&lt;/i> if &lt;b>name&lt;/b> is not a string od doesn't match any existing Panel constructor 
		 	 * @description 
		 	 &lt;p>
		 	 	Stopping a Panel contructor, its reference in kb gets removed.
		 	 	&lt;br/>When passing &lt;b>clean=&lt;i>true&lt;/i>&lt;/b>, all the Panel's instances are dumped. 
		 	 	&lt;br/>When cleaning the Panel's instances, the &lt;b>dump&lt;/b> parameter defines how to access the &lt;b>&lt;i>instance.dump()&lt;/i>&lt;/b>:
		 	 	
		 	 	&lt;ul>
		 	 		&lt;li>&lt;b>&lt;undefined&gt;&lt;/b>||&lt;b>"max"&lt;string&gt;&lt;/b> - sets all instances methods and properties to null&lt;/li>
		 	 		&lt;li>&lt;b>"min"&lt;string&gt;&lt;/b> - sets instances property list to null and returns an exception for all methods when called&lt;/li>
		 	 		&lt;li>&lt;b>&lt;others&gt;&lt;/b> - only returns an exception for all methods when called&lt;/li>
		 	 	&lt;/ul>
		 	 &lt;/p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var panel = _public.setPanel("panel1");
		 	 * var obj = new panel();
		 	 * _public.stop("panel1");
		 	 * //panel is removed from kb, but obj is not dumped 
		 	 * var panel = _public.setPanel("panel1",true);
		 	 * var obj = new panel();
		 	 * _public.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped
		 	 * var panel = _public.setPanel("panel1",true,"min");
		 	 * var obj = new panel();
		 	 * _public.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped in "min" mode
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var panel = kb.setPanel("panel1");
		 	 * var obj = new panel();
		 	 * kb.stop("panel1");
		 	 * //panel is removed from kb, but obj is not dumped 
		 	 * var panel = kb.setPanel("panel1",true);
		 	 * var obj = new panel();
		 	 * kb.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped
		 	 * var panel = kb.setPanel("panel1",true,"min");
		 	 * var obj = new panel();
		 	 * kb.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped in "min" mode
		 	 */
			, stopPanel: function(name,clean,dump){
				if (_public.type(name) !="string" || iPanel.objects[name]===undefined) return false;
				if (clean) for (var i in iPanel.objects[name].inst) iPanel.objects[name].inst[i].dump(dump);
				var _objects = _public.clone(iPanel.objects);
				delete _objects[name];
				_private.defineProperty(iPanel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				return true;
			}
			/**@ignore*/
			, loadFile: function(params) {
				params = _public.extend({
					"method" : "GET"
					, "dataType": "application/x-www-form-urlencoded"
				}, params, true);
				if (params["url"]) {
					var xmlhttp;
					if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
						xmlhttp = new XMLHttpRequest();
					} else {// code for IE6, IE5
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}
					xmlhttp.onreadystatechange = function() {
						if (xmlhttp.readyState == 4) {
							if (xmlhttp.status == 200)
								if (params["success"])
									params["success"](xmlhttp.responseText);
								else {
									if (params["error"])
										params["error"](xmlhttp);
								}
						} else if (xmlhttp.readyState == 2 && xmlhttp.status !== 200 && params["error"])
							params["error"];
					};
					try {
						xmlhttp.open(params["method"], params["url"], true);
						if (params["method"].toUpperCase()=="POST" && params["data"]){
							xmlhttp.setRequestHeader("Content-type",params["dataType"]);
							//console.log(_public.stringify(params["data"]))
							xmlhttp.send(_public.stringify(params["data"]));
						} else xmlhttp.send();
					} catch(e) {
						if (params["error"])
							params["error"](e);
					}
				}
			}
		};
		
		/**
	     * @protected
	     * @alias kb.constructor.iModel
	     * @class
	     * @returns {iModel.constructor} 
	     */
		//iModels » start
		var iModel = (function(){
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @returns {iModel.definer}
			 * @this iModel.constructor
			 * @description
			 	&lt;p>
			 		iModel constructor
			 		&lt;br/>It contains the definer for iModel contructor instances
			 	&lt;/p>
			 */
			var iModel = function(mType,extension) {
				/**
				 * When a new iModel constructor is created, a _obj is the constructor for new instances
				 */
				var _obj = function(params){
					/**
					 * _obj instances properties are defined with own properties "index" and "list"    
					 */
					_private.defineProperties(this,{
						"index" :{
							configurable: true
							, enumerable: true
							, writable: false
							, value: _obj.index
						}, "list": {
							configurable: true
							, enumerable: true
							, writable: false
							, value: []
						}
					});
					if (params && params.list) this.load(params.list);
					_obj.inst[_obj.index] = this;
					_obj.index++;
					return this;
				};
				_obj.inst = {};
				_obj.index = 0;
				
				/**
				 * _obj prototype is setted up with all the properties and methods defined for the iModel constructor, and "type" is added as own property for the iModel contructor    
				 */
				_obj.prototype = this;
				_private.defineProperties(_obj.prototype,{
					"type": {
						configurable: false
						, enumerable: true
						, writable: false
						, value: mType
					}
				});
				
				/**
			 	 * The constructor's instance is added to the objects list
			 	 */
				var _objects = _public.clone(iModel.objects);
				_objects[mType] = _obj;
				_private.defineProperty(iModel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				
				/**
				 * extension are addded when preloaded when defined in iModel contructor creation     
				 */
				_public.extendModel(mType,extension);
				
				return _obj;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @description 
			 	&lt;p>Collection of iModel constructor's instances&lt;/p>
			 	&lt;p>The &lt;b>objects&lt;/b> collection can only be overwritten using &lt;i>&lt;b>_private.defineProperty&lt;/b>&lt;/i> &lt;/p>
			 */
			_private.defineProperty(iModel,"objects",{
				configurable: true
				, enumerable: true
				, writable: false
				, value: {}
			});
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @returns {iModel.instance}
			 * @this Model.instance
			 */
			var _loadList = function(list){
				var _list_prop = _public.clone(_properties["list"]);
				_list_prop.value=(arguments.length==1 && (_public.type(list)=="array"||_public.type(list)=="object")?list:[].slice.call(arguments))||[];
				_private.defineProperty(this,"list",_list_prop);
				_private.defineProperty(this,"templist",_list_prop);
				return this;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @returns {iModel.instance.templist}
			 * @this iModel.instance
			 */
			var _filterList = function(criteria){
				var _templist_prop = _public.clone(_properties["list"])
					, _list = _public.clone(this.list)
					, _list_type = _public.type(_list) 
					, i = _list_type=="array"?_list.length:undefined; 
				;
				
				if (_list_type=="array") {
					while(i--) if (!criteria.call(_list,i)) _list.splice(i,1);
				} else if (_list_type=="object") {
					for (i in _list) {
						if (!criteria.call(_list,i)) delete _list[i];
					}
				}
				_templist_prop.value=_list;
				_private.defineProperty(this,"templist",_templist_prop);
				return this.templist;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @returns {iModel.instance}
			 * @this iModel.instance
			 */
			var _cleanList = function(){
				var _list_prop = _public.clone(_properties["list"]);
				_list_prop.value=[];
				_private.defineProperty(this,"list",_list_prop);
				_private.defineProperty(this,"templist",_list_prop);
				return this;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @description
			 	&lt;p>
			 		All methods and properties contained in &lt;b>_properties&lt;/b> are then defined in the iModel constructor prototype.
			 		&lt;br/>Methods are wrapped  in &lt;i>&lt;b>_private.wrapInstanceMethod()&lt;/b>&lt;/i> to not allow &lt;b>dumped&lt;/b> instences to use them 
			 	&lt;/p>
			 * @property {undefined} prototype.options - Collection of iModel constructor properties, open to the user for manipulation
			 * @property {array} prototype.list - Default empty list of elements.
			 * @property {function} prototype.load - Populates &lt;b>iModel.instance.list&lt;/b>
			 * @property {function} prototype.filter - Populate &lt;b>iModel.instance.templist&lt;/b>
			 * @property {function} prototype.clean - Cleans &lt;b>iModel.instance.list&lt;/b> and &lt;b>Model.instance.templist&lt;/b>
			 * @property {function} prototype.dump - Removes &lt;b>iModel.instance&lt;/b>
			 */
			var _properties = {
				"options": {
					configurable: true
					, enumerable: true
					, writable: true
				}
				, "list": {
					configurable: true
					, enumerable: true
					, writable: false
					, value: []
				}
				, "load": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_loadList)
				}
				, "filter": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_filterList)
				}
				, "clean": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_cleanList)
				}
				/**"dump" method uses the kb protected _private.dumpInstance()*/
				, "dump": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_private.dumpInstance(),"Object instance has been already dumped")
				}
			};
			
			/**Defining prototypical properties for the iModel constructor*/
			for (prop in _properties) {
				_private.defineProperty(iModel.prototype,prop,_properties[prop]);
				_private.iModelPrototype.push(prop);
			}
			
			return iModel;
		})();
		//iModels » end
		
		/**
	     * @protected
	     * @alias kb.constructor.iPanel
	     * @class
	     * @returns {iPanel.constructor} 
	     */
		//iPanel » start
		var iPanel = (function() {
			/**
			 * @protected
			 * @memberof kb.constructor.iPanel
			 * @returns {iPanel.definer}
			 * @this iPanel.constructor
			 * @description
			 	&lt;p>
			 		iPanel constructor
			 		&lt;br/>It contains the definer for iPanel instances
			 	&lt;/p>
			 */
			var iPanel = function(pType,models,extension) {
				/**
				 * When a new iPanel constructor is created, a _obj is the constructor for new instances
				 */
				var _obj = function(params){
					/**
					 * _obj instances properties are defined with own properties "index" and "models"    
					 */
					var _models = _obj.prototype.models || []
						, i = _models.length
						, _props = {
								"index" :{
									configurable: true
									, enumerable: true
									, writable: false
									, value: _obj.index
								}
								, "models": {
									configurable: true
									, enumerable: true
									, writable: false
									, value: {}
								}
							}
					;
					/**
					 * Inherited "models" property is turned into own property for the iPanel constructor's instance, containig the collection of newly created iModel contructors instances.
					 * iModel contructor "prototype.models" property is maintained
					 */
					while(i--) _props.models.value[_models[i]] = new iModel.objects[_models[i]];
					_private.defineProperties(this,_props);
					
					_obj.inst[_obj.index] = this;
					_obj.index++;
					return this;
				};
				_obj.inst = {};
				_obj.index = 0;
				
				/**
				 * _obj prototype is setted up with all the properties and methods defined for the iPanel constructor, and "type" and "models" are added as own property for the iPanel contructor
				 */
				_obj.prototype = this;
				_private.defineProperties(_obj.prototype,{
					"type": {
						configurable: false
						, enumerable: true
						, writable: false
						, value: pType
					}
					, "models": {
						configurable: false
						, enumerable: true
						, writable: false
						, value: models
					}
				});
				
				/**
			 	 * The constructor's instance is added to the objects list
			 	 */
				var _objects = _public.clone(iPanel.objects);
				_objects[pType] = _obj;
				_private.defineProperty(iPanel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				
				/**
				 * extension are addded when preloaded when defined in iPanel contructor creation     
				 */
				_public.extendPanel(pType,extension);
				
				return _obj;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iPanel
			 * @description 
			 	&lt;p>Collection of iPanel constructor's instances&lt;/p>
			 	&lt;p>The &lt;b>objects&lt;/b> collection can only be overwritten using &lt;i>&lt;b>_private.defineProperty&lt;/b>&lt;/i> &lt;/p>
			 */
			_private.defineProperty(iPanel,"objects",{
				configurable: true
				, enumerable: true
				, writable: false
				, value: {}
			});
			
			/**
			 * @protected
			 * @memberof kb.constructor.iPanel
			 * @description
			 	&lt;p>
			 		All methods and properties contained in &lt;b>_properties&lt;/b> are then defined in the Panel constructor prototype
			 		&lt;br/>Methods are wrapped  in &lt;i>&lt;b>_private.wrapInstanceMethod()&lt;/b>&lt;/i> to not allow &lt;b>dumped&lt;/b> instences to use them 
			 	&lt;/p>
			 * @property {undefined} prototype.options - Collection of iPanel constructor properties, open to the user for manipulation
			 * @property {array} prototype.models - Default empty list of model names.
			 * @property {function} prototype.dump - Removes &lt;b>iPanel.instance&lt;/b>
			 */
			var _properties = {
				"options": {
					configurable: true
					, enumerable: true
					, writable: true
				}
				, "models": {
					configurable: true
					, enumerable: true
					, writable: false
					, value: []
				}
				/**"dump" method uses the kb protected _private.dumpInstance()*/
				, "dump": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_private.dumpInstance(),"Object instance has been already dumped")
				}
			};
			
			/**Defining prototypical properties for the iPanel constructor*/
			for (prop in _properties) {
				_private.defineProperty(iPanel.prototype,prop,_properties[prop]);
				_private.iPanelPrototype.push(prop);
			}
			
			return iPanel;
		})();
		//iPanel » end
		
		/**Defining public properties and methods contained in &lt;b>_public&lt;/b> for &lt;b>kb&lt;/b> adding them to &lt;b>_self&lt;/b>. &lt;b>kb&lt;/b> public properties and methods cannot be overwritten */
		//Switch codes below to manage public kb properties one at the time
		for (var key in _public) _private.defineProperty(_self,key,_private.getKBObjectDefinition(_public[key]));
		/*_private.defineProperties(_self,{
			"clone": _private.getKBObjectDefinition(_public.clone)
			, "extend": _private.getKBObjectDefinition(_public.extend)
			, "stringify": _private.getKBObjectDefinition(_public.stringify)
			, "type": _private.getKBObjectDefinition(_public.type)
			, "setModel": _private.getKBObjectDefinition(_public.setModel)
			, "getModel": _private.getKBObjectDefinition(_public.getModel)
			, "stopModel": _private.getKBObjectDefinition(_public.dumpModel)
			, "setPanel": _private.getKBObjectDefinition(_public.setPanel)
			, "getPanel": _private.getKBObjectDefinition(_public.getPanel)
			, "stopPanel": _private.getKBObjectDefinition(_public.dumpPanel)
			, "loadFile": _private.getKBObjectDefinition(_public.loadFile)
		});*/
		
		return _self;
	}
)(kb||undefined);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="kb.constructor.iModel.html">iModel</a></li><li><a href="kb.constructor.iPanel.html">iPanel</a></li></ul><h3>Namespaces</h3><ul><li><a href="kb.html">kb</a></li><li><a href="kb.constructor.html">constructor</a></li><li><a href="kb.constructor._private.html">_private</a></li><li><a href="kb.constructor._public.html">_public</a></li><li><a href="kb.constructor._self.html">_self</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Tue Jan 28 2014 16:08:50 GMT-0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
