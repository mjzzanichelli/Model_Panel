/**
 * @fileOverview Wiki Text KB
 * @author José Marco Zanichelli
 * @version: 0.1
 */

/**
 * @namespace
 * @description
  <p>kb framework is generated by an anonymous <b>constructor</b></p>
  <p>It can be named differently at any time </p>
 * @example
 * var kb = (
 * //.............
 *	if (kb) return kb;
 * 
 * //kb renamed to fwk 
 * var fwk = (
 * //.............
 *	if (fwk) return fwk;
 */
var kb = (
	
	/**
     * Creates the kb instance
     * @protected
     * @alias kb.constructor
     * @namespace
     */
	function(){
		
		if (kb) return kb;
		
		/**
	     * @protected
	     * @alias kb.constructor._self
	     * @namespace
	     * @description Capsule Object for constructor instance.
	     */
		var _self = {};
		
		/**
	     * @protected
	     * @alias kb.constructor._private
	     * @namespace 
	     * @description
	     	<p>List of private methods that can be used inside the constructor.</p>
	     	<p>All properties listed in <b>_private</b> are only accessible using using <b>_private.&lt;propertyName&gt;</b> inside kb.constructor</p>
	     * @property {function} _private.getKBObjectDefinition - {@link kb.constructor._private.getKBObjectDefinition (this)} Applies default object definition properties
		 * @property {array} _private.iModelPrototype - {@link kb.constructor._private.iModelPrototype (this)} Collection of {@link kb.constructor.iModel Model} Constructor prototype properties
		 * @property {array} _private.iPanelPrototype - {@link kb.constructor._private.iPanelPrototype (this)} Collection of {@link kb.constructor.iPanel Panel} Constructor prototype properties
		 * @property {function} _private.dumpInstance - {@link kb.constructor._private.dumpInstance (this)} Global method to dump {@link kb.constructor.iModel Models} and {@link kb.constructor.iPanel Panels} instances 
		 * @property {function} _private.wrapInstanceMethod - {@link kb.constructor._private.wrapInstanceMethod (this)} Wrapper to avoid prototypical methods of {@link kb.constructor.iModel Models} and {@link kb.constructor.iPanel Panels} instances been called when dumped
	     */
		var _private = {
					
			/**
			 * @method kb.constructor._private.getKBObjectDefinition
		 	 * @param {any} value - Default value for the new property
		 	 * @param {object} [extension] - Configuration object to modify the default definition set
		 	 * @returns {object} Configuration object to be used with Object.defineProperty 
		 	 * @description 
		 	 <p>Applies default object definition properties.</p> 
		 	 <p>
		 	 	When argument "extension" is not declared, default is applied to the returning value:
		 	 	<i>
		 	 	<br>{
		 	 		<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>configurable:</b> false
		 	 		<br>&nbsp;&nbsp;&nbsp;&nbsp;, <b>enumerable:</b> true
		 	 		<br>&nbsp;&nbsp;&nbsp;&nbsp;, <b>writable:</b> false
		 	 	<br>}
		 	 	</i>
		 	 </p>
		 	 * @example var property = _private.getKBObjectDefinition("property_value")
		 	 * //property value: {configurable: false, enumerable: true, writable: false, value: "property_value"}
		 	 * 
		 	 * var property = _private.getKBObjectDefinition("property_value",{configurable: true})
		 	 * //property value: {configurable: true, enumerable: true, writable: false, value: "property_value"}
		 	 */
			getKBObjectDefinition: function(value,extension){
				var _props = {
					configurable: false
					, enumerable: true
					, writable: false
					, value: value
				};
				_props = _public.extend(_props,extension);
				return _props;
			}
			
			/**
			 * @member {String[]} kb.constructor._private.iModelPrototype
			 * @description 
			 	<p>Collection of {@link kb.constructor.iModel Model} Constructor prototype properties.</p>
			 	<p>Used to match Model's extension names against the Model's native methods and properties.</p>    
		 	 */
			, iModelPrototype: []
			
			/**
			 * @member {String[]} kb.constructor._private.iPanelPrototype
			 * @description
			 	<p>Collection of {@link kb.constructor.iPanel Panel} Constructor prototype properties.</p>
			 	<p>Used to match Panel's extension names against the Panel's native methods and properties.</p>
		 	 */
			, iPanelPrototype: []
			
			/**
			 * @method kb.constructor._private.dumpInstance
		 	 * @returns {undefined} When dumping a Panel, all referenced Models instances get dumped too 
		 	 * @description 
		 	 <p>
		 	 	When a Model or Panel instance calls the method <b>dump()</b>, it will effectively 
		 	 	<br>fire the global method <b>_private.dumpInstance()</b> wrapped inside <b>_private.wrapInstanceMethod</b>
		 	 </p>
		 	 * @example var obj = new Model("model")
		 	 * obj = obj.dump();
		 	 * //obj.dump actually executes _private.wrapInstanceMethod(_private.dumpInstance())
		 	 * //obj is now undefined
		 	 */
			, dumpInstance: function(){
				var _dumper = function(type){
					var _obj = this.constructor.objects[this.type]
						, _inst = _obj.inst;
					;

					delete _obj.inst[this.index];
					if (this.models) for (name in this.models) this.models[name].dump(type);

					if (type==undefined || type=="max"){
						for (i in _obj.prototype) Object.defineProperty(this,i,{configurable:false,enumerable:false,writable:false,value: null});
						for (i in this.constructor.prototype) Object.defineProperty(this,i,{configurable:false,enumerable:false,writable:false,value: null});
					}
					if (type=="min" || type=="max"){
						var _props = Object.getOwnPropertyNames(this);
						i =  _props.length;
						//while(i--) delete this[_props[i]];
						while(i--) {
							//console.log(_props[i],Object.getOwnPropertyDescriptor(this,_props[i]))
							Object.defineProperty(this,_props[i],_public.extend(Object.getOwnPropertyDescriptor(this,_props[i]),{configurable:false,enumerable:false,writable:false,value: null},true));
						}
					}
					
					Object.defineProperty(this,"dumped",{
						configurable: false
						, enumerable: true
						, writable: false
						, value: true
					});
					
					return undefined;
				};
				return _dumper;
			}
			
			/**
			 * @method kb.constructor._private.wrapInstanceMethod
		 	 * @param {function} method - function to be exectued
		 	 * @param {string} [message] - Alternative exception message 
		 	 * @returns {function} When <b>dumped</b>!=<i>true</i> it returns instance method executed, otherwise throws an exception
		 	 * @this Model.instance||Panel.instance
		 	 * @description 
		 	 <p>
		 	 	Prevents dumped instances of Models and Panels to call any native methods.    
		 	 	<br>In order to verify the instance status, it check against its property <b>dumped</b></b>
		 	 </p>
		 	 * @example
			 * var fn = function(){}
			 * fn = _private.wrapInstanceMethod(fn);
			 * //fn will now check for a property fn.dumped not been true to execute
			 * //otherwise it will fire the default error message "Object instance has been dumped"
			 *   
			 * var fn = function(){}
			 * fn = _private.wrapInstanceMethod(fn,"my custom error");
			 * //fn will now check for a property fn.dumped not been true to execute
			 * //otherwise it will fire an error message "my custom error"
		 	 */
			, wrapInstanceMethod: function(method,message){
				message = message || "Object instance has been dumped";
				var _wrapper = function(){
					if (!this.dumped) return method.apply(this,arguments);
					else throw new Error(message);
				};
				return _wrapper;
			}
		};
		
		/**
	     * @public
	     * @alias kb.constructor._public
	     * @namespace
	     * @description
	     	<p>List of public methods to be attached to capsule {@link kb.constructor._self _self} in the {@link kb.constructor constructor}.</p>
	     	<p>All properties listed in <b>_public</b> are accessible using <b>kb.&lt;propertyName&gt;</b> from outside kb.constructor or inside kb.constructor using <b>_public.&lt;propertyName&gt;.</b></p>
	     * @property {function} _public.clone||kb.clone - {@link kb.constructor._public.clone (this)} Creates a copy of literal objects and array. No Model's or Panel's instance clones are allowed.
		 * @property {function} _public.extend||kb.extend - {@link kb.constructor._public.extend (this)} Extend literal objects
		 * @property {array} _public.stringify||kb.stringify - {@link kb.constructor._public.stringify (this)} Returns string representations for literal objects and arrays 
		 * @property {array} _public.type||kb.type - {@link kb.constructor._public.type (this)} Returns the type of a var
		 * @property {function} _public.setModel||kb.setModel - {@link kb.constructor._public.setModel (this)} Creates a Model constructor
		 * @property {function} _public.getModel||kb.getModel - {@link kb.constructor._public.getModel (this)} Returns the list of Models or a specific Model constructor
		 * @property {function} _public.extendModel||kb.extendModel - {@link kb.constructor._public.extendModel (this)} Attaches new methods and properties onto a Model constructor
		 * @property {function} _public.unextendModel||kb.unextendModel - {@link kb.constructor._public.unextendModel (this)} Removes attached methods and properties from a Model constructor
		 * @property {function} _public.stopModel||kb.stopModel - {@link kb.constructor._public.stopModel (this)} Kills Model constructors references inside kb 
		 * @property {function} _public.setPanel||kb.setPanel - {@link kb.constructor._public.setPanel (this)} Creates a Panel constructor
		 * @property {function} _public.getPanel||kb.getPanel - {@link kb.constructor._public.getPanel (this)}Returns the list of Panels or a specific Panel constructor
		 * @property {function} _public.extendPanel||kb.extendPanel - {@link kb.constructor._public.extendPanel (this)}Attaches new methods and properties onto a Panel constructor
		 * @property {function} _public.unextendPanel||kb.unextendPanel - {@link kb.constructor._public.unextendPanel (this)}Removes attached methods and properties from a Panel constructor
		 * @property {function} _public.stopPanel||kb.stopPanel - {@link kb.constructor._public.stopPanel (this)}Kills Model constructors references inside kb 
	     */
		var _public = {
			
			/**
			 * @method kb.constructor._public.clone
		 	 * @param {object|array} obj - base object to copy from
		 	 * @returns {object|array} 
		 	 * @description 
		 	 <p>
		 	 	A new object is generated from using the constructor of obj.
		 	 	<br>Base objects such as Models and Panels, that have properties defined as <i><b>configurable</b>=false</i>, cannot be cloned.</b>
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = _public.clone(obj);
		 	 * //obj && newobj will be identical
		 	 * var arr = ["item"]
		 	 * var newarr = _public.clone(arr);
		 	 * //arr && newarr will be identical
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = kb.clone("obj");
		 	 * //obj && newobj will be identical
		 	 * var arr = ["item"]
		 	 * var newarr = kb.clone(arr);
		 	 * //arr && newarr will be identical
		 	 */
			clone: function(obj){
			    if(obj == null || typeof(obj) != 'object') return obj;
			    var temp = obj.constructor(); // changed
			    for(var key in obj) temp[key] = _public.clone(obj[key]);
			    return temp;
			}
			
			/**
			 * @method kb.constructor._public.extend
		 	 * @param {object} base - literal object to be extend
		 	 * @param {object} add - new keys to be added to the base 
		 	 * @param {boolean} [overwrite] - resolves merging of identical keys
		 	 * @returns {object} 
		 	 * @description 
		 	 <p>
		 	 	A new object is generated adding <b>add</b> keys to exting <b>base</b> keys.  
		 	 	<br>When a key in <b>add</b> already exsits in <b>base</b>, it overwrites the origin if <i><b>overwrite</b>=true</i></b>
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var _obj = _public.extend(obj,{"newprop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value", "newprop":"newvalue"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = _public.extend(obj,{"prop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = _public.extend(obj,{"prop":"newvalue"},true);
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"newvalue"}
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = {"prop":"value"}
		 	 * var _obj = kb.extend(obj,{"newprop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value", "newprop":"newvalue"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = kb.extend(obj,{"prop":"newvalue"});
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"value"}
		 	 * var obj = {"prop":"value"}
		 	 * var newobj = kb.extend(obj,{"prop":"newvalue"},true);
		 	 * //obj value: {"prop":"value"}
		 	 * //newobj value: {"prop":"newvalue"}
		 	 */
			, extend: function(base,add,overwrite){
				overwrite = overwrite || false;
	            var _extend = {},key;
	            for (key in base) _extend[key] = base[key];
	            for (key in add) if (overwrite || !base[key])_extend[key] = add[key];
	            return _extend;
	        }
	        
	        /**
			 * @method kb.constructor._public.stringify
		 	 * @param {object|array} obj - object to get the string from
		 	 * @returns {string} 
		 	 * @description 
		 	 <p>
		 	 	Given a literal object or array, it returns its string representation.  
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = new Object();
		 	 * obj.prop = "value"
		 	 * var objstring = _public.stringify(obj);
		 	 * //objstring value: "{'prop':'value'}"
		 	 * var arr = new Array();
		 	 * arr.push("item")
		 	 * var arrstring = _public.stringify(arr);
		 	 * //arrstring value: "['item']"
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = new Object();
		 	 * obj.prop = "value"
		 	 * var objstring = kb.stringify(obj);
		 	 * //objstring value: "{'prop':'value'}"
		 	 * var arr = new Array();
		 	 * arr.push("item")
		 	 * var arrstring = kb.stringify(arr);
		 	 * //arrstring value: "['item']"
		 	 */
	        , stringify: function(obj){
	            var t = typeof (obj);
	            if (t != "object" || obj === null) {
	                // simple data type
	                if (t == "string") obj = '"'+obj+'"';
	                return String(obj);
	            }
	            else {
	                // recurse array or object
	                var n, v, json = [], arr = (obj && obj.constructor == Array);
	                for (n in obj) {
	                    v = obj[n]; t = typeof(v);
	                    //if (t == "string") v = '"'+v.replace(/\"/gi,'%22')+'"';
	                    if (t == "string") v = '"'+v+'"';
	                    else if (t == "object" && v !== null) v = this.stringify(v);
	                    json.push((arr ? "" : '"' + n + '":') + String(v));
	                }
	                return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
	            }
	        }
	        
	        /**
			 * @method kb.constructor._public.type
		 	 * @param {any} object - unknown object to identify
		 	 * @returns {string} Given an unknown object, it returns its type in a string 
		 	 * @description 
		 	 <p>
		 	 	Currently recognizing the following types:
		 	 	<ul>
		 	 		<li><b>null</b></li>
		 	 		<li><b>undefined</b></li>
		 	 		<li><b>string</b></li>
		 	 		<li><b>array</b></li>
		 	 		<li><b>object</b></li>
		 	 		<li><b>function</b></li>
		 	 		<li><b>html</b></li>
		 	 	</ul>
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var obj = function(){return "I'm a string"};
		 	 * var objtype = _public.type(obj);
		 	 * //objtype value: "function"
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var obj = function(){return "I'm a string"};
		 	 * var objtype = kb.type(obj);
		 	 * //objtype value: "function"
		 	 */
	        , type : function(object){
	            var _stringConstructor = "".constructor
	            , _arrayConstructor = [].constructor
	            , _objectConstructor = {}.constructor
	            , _functionConstructor = function(){}.constructor
	            , _type = "";
	
	            if (object === null) {
	                _type = "null";
	            }
	            else if (object === undefined) {
	                _type = "undefined";
	            }
	            else if (object.constructor === _stringConstructor) {
	                _type = "string";
	            }
	            else if (object.constructor === _arrayConstructor) {
	                _type = "array";
	            }
	            else if (object.constructor === _objectConstructor) {
	                _type = "object";
	            }
	            else if (object.constructor === _functionConstructor) {
	                _type = "function";
	            }
	            else if (object.nodeType !== undefined) {
	                _type = "html";
	            }
	            _stringConstructor = _arrayConstructor =  _objectConstructor = null;
	            return _type;
	        }
	        
	        /**
			 * @method kb.constructor._public.setModel
		 	 * @param {string} mType - Model constructor identifier
		 	 * @param {object} [extension] - Additional set of properties and method to be attached
		 	 * @returns {iModel} A new iModel constructor <b>function</b> is generated and referenced inside <b>kb</b> 
		 	 * @description 
		 	 <p>
		 	 	When a new Model constructor is generated, it can be retrieved using <b>kb</b> and <b>_public</b>
		 	 	<br/><i><b>getModel(</b>modelType<b>)</b></i> 
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var objmodel = _public.setModel("model",{"fn":function(){}});
		 	 * //objmodel is a new Model constructor
		 	 * var objmodelinst = new objmodel();
		 	 * //objmodelinst is an instance objmodel and inherits all methods, properties and extensions.
		 	 * var check = (objmodel===_public.getModel("model"));
		 	 * //check value: true
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var objmodel = kb.setModel("model",{"fn":function(){}});
		 	 * //objmodel is a new Model constructor
		 	 * var objmodelinst = new objmodel();
		 	 * //objmodelinst is an instance objmodel and inherits all methods, properties and extensions.
		 	 * var check = (objmodel===kb.getModel("model"));
		 	 * //check value: true
		 	 */
			, setModel: function(mType,extension){
				if (_public.type(mType) != "string" && _public.getModel(mType)!== undefined) return undefined;
				var _OM = new iModel(mType,extension);
				return _OM;
			}
			
			/**
			 * @method kb.constructor._public.getModel
		 	 * @param {string} [name] - Model type
		 	 * @returns {array|iModel} When <b>name</b> is specified it returns the specified Model constructor, otherwise a list of all active Model contructors   
		 	 * @description 
		 	 <p>
		 	 	Retrieves active Model constructors
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setModel("model1");_public.setModel("model2")
		 	 * var models = _public.getModel();
		 	 * //models value: [iModel&lt;model1&gt;, iModel&lt;model2&gt;]
		 	 * var model = _public.getModel("model1");
		 	 * //model value: iModel&lt;model1&gt;
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setModel("model1");kb.setModel("model2")
		 	 * var models = kb.getModel();
		 	 * //models value: [iModel&lt;model1&gt;, iModel&lt;model2&gt;]
		 	 * var model = kb.getModel("model1");
		 	 * //model value: iModel&lt;model1&gt;
		 	 */
			, getModel: function(name){
				return name ? iModel.objects[name] : iModel.objects;
			}
			
			/**
			 * @method kb.constructor._public.extendModel
		 	 * @param {string} name - Model type
		 	 * @param {object} extension - Set of properties and method to extend onto a Model contructor
		 	 * @returns {iModel} <i><b>False</b></i> is returned if the <b>name</b> doesn't match any Model constructor, or <b>extension</b> is not a valid object   
		 	 * @description 
		 	 <p>
		 	 	Attached exstensiones can be overwritten, but only calling <b>extendModel()</b> a second time 
		 	 	<br/>or redifining the constructor object property: <i><b>Object.defineProperty(Model,"extension",definingProperties)</b></i>.
		 	 	<br/><br/>Native methods contained in list <b>_private.iModelPrototype</b> cannot be overwritten.
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setModel("model1");
		 	 * var model = _public.extendModel("model1",{"fn":function(){}});
		 	 * //model is iModel&lt;model1&gt; with added method model.fn 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setModel("model1");
		 	 * var model = kb.extendModel("model1",{"fn":function(){}});
		 	 * //model is iModel&lt;model1&gt; with added method model.fn
		 	 */
			, extendModel: function(name,extension){
				if (_public.type(name) != "string" || iModel.objects[name]===undefined || _public.type(extension) != "object") return false;
				var _model_proto = [""].concat(_private.iModelPrototype).concat([""]).join();
				for (prop in extension) if (_model_proto.indexOf(","+prop+",")<0) Object.defineProperty(iModel.objects[name].prototype,prop,_private.getKBObjectDefinition(extension[prop],{configurable:true}));
				return iModel.objects[name];
			}
			
			/**
			 * @method kb.constructor._public.unextendModel
		 	 * @param {string} name - Model type
		 	 * @param {string} extension - Model extension name
		 	 * @returns {iModel} <i><b>False</b></i> is returned if the <b>name</b> doesn't match any Model constructor, or <b>extension</b> is not a valid string or a method in <b>iModelPrototype</b>  
		 	 * @description 
		 	 <p>
		 	 	Only methods and properties that have been previuosly attached onto a Model calling <b>extendModel()</b> can be unextended. 
		 	 	<br/><br/>Native methods contained in list <b>_private.iModelPrototype</b> cannot be unextended.
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setModel("model1");
		 	 * _public.extendModel("model1",{"fn":function(){},"prop":"value"});
		 	 * var model = _public.unextendModel("model1","fn");
		 	 * //model is iModel&lt;model1&gt; with added method model.prop only 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setModel("model1");
		 	 * kb.extendModel("model1",{"fn":function(){},"prop":"value"});
		 	 * var model = kb.unextendModel("model1","fn");
		 	 * //model is iModel&lt;model1&gt; with added method model.prop only
		 	 */
			, unextendModel: function(name,extension){
				if (_public.type(name) != "string" || iModel.objects[name]===undefined || _public.type(extension) != "string" || [""].concat(_private.iModelPrototype).concat([""]).join().indexOf(","+extension+",") >= 0) return false;
				delete iModel.objects[name].prototype[extension];
				return iModel.objects[name];
			}
			
			/**
			 * @method kb.constructor._public.stopModel
		 	 * @param {string} name - Model type
		 	 * @param {boolean} [clean] - Option for cleaning Model instances
		 	 * @param {string} [dump] - Option for dumping Model instances when cleaning
		 	 * @returns {boolean} <i><b>True</b></i> is returned if cleaning happened successfully, <i><b>False</b></i> if <b>name</b> is not a string od doesn't match any existing Model constructor 
		 	 * @description 
		 	 <p>
		 	 	Stopping a Model contructor, its reference in kb gets removed.
		 	 	<br/>When passing <b>clean=<i>true</i></b>, all the Model's instances are dumped. 
		 	 	<br/>When cleaning the Model's instances, the <b>dump</b> parameter defines how to access the <b><i>instance.dump()</i></b>:
		 	 	<ul>
		 	 		<li><b>&lt;undefined&gt;</b>||<b>"max"&lt;string&gt;</b> - sets all instances methods and properties to null</li>
		 	 		<li><b>"min"&lt;string&gt;</b> - sets instances property list to null and returns an exception for all methods when called</li>
		 	 		<li><b>&lt;others&gt;</b> - only returns an exception for all methods when called</li>
		 	 	</ul>
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var model = _public.setModel("model1");
		 	 * var obj = new model();
		 	 * _public.stop("model1");
		 	 * //model is removed from kb, but obj is not dumped 
		 	 * var model = _public.setModel("model1",true);
		 	 * var obj = new model();
		 	 * _public.stop("model1");
		 	 * //model is removed from kb, and obj is dumped
		 	 * var model = _public.setModel("model1",true,"min");
		 	 * var obj = new model();
		 	 * _public.stop("model1");
		 	 * //model is removed from kb, and obj is dumped in "min" mode
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var model = kb.setModel("model1");
		 	 * var obj = new model();
		 	 * kb.stop("model1");
		 	 * //model is removed from kb, but obj is not dumped 
		 	 * var model = kb.setModel("model1",true);
		 	 * var obj = new model();
		 	 * kb.stop("model1");
		 	 * //model is removed from kb, and obj is dumped
		 	 * var model = kb.setModel("model1",true,"min");
		 	 * var obj = new model();
		 	 * kb.stop("model1");
		 	 * //model is removed from kb, and obj is dumped in "min" mode
		 	 */
			, stopModel: function(name,clean,dump){
				if (_public.type(name) != "string" || iModel.objects[name]===undefined) return false;
				if (clean) for (var i in iModel.objects[name].inst) iModel.objects[name].inst[i].dump(dump);
				var _objects = _public.clone(iModel.objects);
				delete _objects[name];
				Object.defineProperty(iModel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				return true;
			}
			
			/**
			 * @method kb.constructor._public.setPanel
		 	 * @param {string} pType - Panel constructor identifier
		 	 * @param {array} [models] - List of Models constructor to be included
		 	 * @param {object} [extension] - Additional set of properties and method to be attached
		 	 * @returns {iPanel} A new iPanel constructor <b>function</b> is generated and referenced inside <b>kb</b> 
		 	 * @description 
		 	 <p>
		 	 	When a new Panel constructor is generated, it can be retrieved using <b>kb</b> and <b>_public</b>
		 	 	<br/><i><b>getPanel(</b>panelType<b>)</b></i> 
		 	 	<br/>Passing <b>models</b>, an instance for each Model will be created for each instance of the Panel constructor 
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var objpanel = _public.setPanel("panel",[],{"fn":function(){}});
		 	 * //objpanel is a new Panel constructor
		 	 * var objPanelinst = new objpanel();
		 	 * //objpanelinst is an instance objpanel and inherits all methods, properties and extensions.
		 	 * var check = (objpanel===_public.getPanel("panel"));
		 	 * //check value: true
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var objpanel = kb.setPanel("panel",[],{"fn":function(){}});
		 	 * //objpanel is a new Panel constructor
		 	 * var objPanelinst = new objpanel();
		 	 * //objpanelinst is an instance objpanel and inherits all methods, properties and extensions.
		 	 * var check = (objpanel===kb.getPanel("panel"));
		 	 * //check value: true
		 	 */
			, setPanel: function(pType,models,extension){
				if (_public.type(pType) != "string" && _public.getPanel(pType)!== undefined ) return undefined;
				var _OP = new iPanel(pType,models,extension);
				return _OP;
			}
			
			/**
			 * @method kb.constructor._public.getPanel
		 	 * @param {string} [name] - Panel type
		 	 * @returns {array|iPanel} When <b>name</b> is specified it returns the specified Panel constructor, otherwise a list of all active Panel contructors
		 	 * @description 
		 	 <p>
		 	 	Retrieves active Panel constructors
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setPanel("panel1");_public.setPanel("panel2")
		 	 * var panels = _public.getPanel();
		 	 * //panels value: [iPanel&lt;panel1&gt;, iPanel&lt;panel2&gt;]
		 	 * var panel = _public.getPanel("panel1");
		 	 * //panel value: iPanel&lt;panel1&gt;
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setPanel("panel1");kb.setPanel("panel2")
		 	 * var panels = kb.getPanel();
		 	 * //panels value: [iPanel&lt;panel1&gt;, iPanel&lt;panel2&gt;]
		 	 * var panel = kb.getPanel("panel1");
		 	 * //panel value: iPanel&lt;panel1&gt;
		 	 */
			, getPanel: function(name){
				return name ? iPanel.objects[name] : iPanel.objects;
			}
			
			/**
			 * @method kb.constructor._public.extendPanel
		 	 * @param {string} name - Panel type
		 	 * @param {object} extension - Set of properties and method to extend onto a Panel contructor
		 	 * @returns {iPanel} <i><b>False</b></i> is returned if the <b>name</b> doesn't match any Panel constructor, or <b>extension</b> is not a valid object   
		 	 * @description 
		 	 <p>
		 	 	Attached exstensiones can be overwritten, but only calling <b>extendPanel()</b> a second time 
		 	 	<br/>or redifining the constructor object property: <i><b>Object.defineProperty(Panel,"extension",definingProperties)</b></i>.
		 	 	<br/><br/>Native methods contained in list <b>_private.iPanelPrototype</b> cannot be overwritten.
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setPanel("panel1");
		 	 * var panel = _public.extendPanel("panel1",{"fn":function(){}});
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.fn 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setPanel("panel1");
		 	 * var panel = kb.extendPanel("panel1",{"fn":function(){}});
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.fn
		 	 */
			, extendPanel: function(name,extension){
				if (_public.type(name) != "string" || iPanel.objects[name]===undefined || _public.type(extension) != "object") return false;
				var _panel_proto = [""].concat(_private.iPanelPrototype).concat([""]).join();
				for (prop in extension) {
					if (_panel_proto.indexOf(","+prop+",")<0) {
						Object.defineProperty(iPanel.objects[name].prototype,prop,_private.getKBObjectDefinition(extension[prop],{configurable:true}));
					}
				}
				return iPanel.objects[name],"test";
			}
			
			/**
			 * @method kb.constructor._public.unextendPanel
		 	 * @param {string} name - Panel type
		 	 * @param {string} extension - Panel extension name
		 	 * @returns {iPanel} <i><b>False</b></i> is returned if the <b>name</b> doesn't match any Panel constructor, or <b>extension</b> is not a valid string or a method in <b>iPanelPrototype</b>  
		 	 * @description 
		 	 <p>
		 	 	Only methods and properties that have been previuosly attached onto a Model calling <b>extendPanel()</b> can be unextended. 
		 	 	<br/><br/>Native methods contained in list <b>_private.iPanelPrototype</b> cannot be unextended.
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * _public.setPanel("panel1");
		 	 * _public.extendPanel("panel1",{"fn":function(){},"prop":"value"});
		 	 * var panel = _public.unextendPanel("panel1","fn");
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.prop only 
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * kb.setPanel("panel1");
		 	 * kb.extendPanel("panel1",{"fn":function(){},"prop":"value"});
		 	 * var panel = kb.unextendPanel("panel1","fn");
		 	 * //panel is iPanel&lt;panel1&gt; with added method panel.prop only
		 	 */
			, unextendPanel: function(name,extension){
				if (_public.type(name) != "string" || iPanel.objects[name]===undefined || _public.type(extension) != "string" || [""].concat(_private.iPanelPrototype).concat([""]).join().indexOf(","+extension+",") >= 0) return false;
				delete iPanel.objects[name].prototype[extension];
				return iPanel.objects[name];
			}
			
			/**
			 * @method kb.constructor._public.stopPanel
		 	 * @param {string} name - Panel type
		 	 * @param {boolean} [clean] - Option for cleaning Panel instances
		 	 * @param {string} [dump] - Option for dumping Panel instances when cleaning
		 	 * @returns {boolean} <i><b>True</b></i> is returned if cleaning happened successfully, <i><b>False</b></i> if <b>name</b> is not a string od doesn't match any existing Panel constructor 
		 	 * @description 
		 	 <p>
		 	 	Stopping a Panel contructor, its reference in kb gets removed.
		 	 	<br/>When passing <b>clean=<i>true</i></b>, all the Panel's instances are dumped. 
		 	 	<br/>When cleaning the Panel's instances, the <b>dump</b> parameter defines how to access the <b><i>instance.dump()</i></b>:
		 	 	
		 	 	<ul>
		 	 		<li><b>&lt;undefined&gt;</b>||<b>"max"&lt;string&gt;</b> - sets all instances methods and properties to null</li>
		 	 		<li><b>"min"&lt;string&gt;</b> - sets instances property list to null and returns an exception for all methods when called</li>
		 	 		<li><b>&lt;others&gt;</b> - only returns an exception for all methods when called</li>
		 	 	</ul>
		 	 </p>
		 	 * @example
		 	 * //INSIDE kb.constructor
		 	 * var panel = _public.setPanel("panel1");
		 	 * var obj = new panel();
		 	 * _public.stop("panel1");
		 	 * //panel is removed from kb, but obj is not dumped 
		 	 * var panel = _public.setPanel("panel1",true);
		 	 * var obj = new panel();
		 	 * _public.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped
		 	 * var panel = _public.setPanel("panel1",true,"min");
		 	 * var obj = new panel();
		 	 * _public.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped in "min" mode
		 	 * 
		 	 * //OUTSIDE kb.constructor
		 	 * var panel = kb.setPanel("panel1");
		 	 * var obj = new panel();
		 	 * kb.stop("panel1");
		 	 * //panel is removed from kb, but obj is not dumped 
		 	 * var panel = kb.setPanel("panel1",true);
		 	 * var obj = new panel();
		 	 * kb.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped
		 	 * var panel = kb.setPanel("panel1",true,"min");
		 	 * var obj = new panel();
		 	 * kb.stop("panel1");
		 	 * //panel is removed from kb, and obj is dumped in "min" mode
		 	 */
			, stopPanel: function(name,clean,dump){
				if (_public.type(name) !="string" || iPanel.objects[name]===undefined) return false;
				if (clean) for (var i in iPanel.objects[name].inst) iPanel.objects[name].inst[i].dump(dump);
				var _objects = _public.clone(iPanel.objects);
				delete _objects[name];
				Object.defineProperty(iPanel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				return true;
			}
			/**@ignore*/
			, loadFile: function(params) {
				params = _public.extend({
					"method" : "GET"
					, "dataType": "application/x-www-form-urlencoded"
				}, params, true);
				if (params["url"]) {
					var xmlhttp;
					if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
						xmlhttp = new XMLHttpRequest();
					} else {// code for IE6, IE5
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}
					xmlhttp.onreadystatechange = function() {
						if (xmlhttp.readyState == 4) {
							if (xmlhttp.status == 200)
								if (params["success"])
									params["success"](xmlhttp.responseText);
								else {
									if (params["error"])
										params["error"](xmlhttp);
								}
						} else if (xmlhttp.readyState == 2 && xmlhttp.status !== 200 && params["error"])
							params["error"];
					};
					try {
						xmlhttp.open(params["method"], params["url"], true);
						if (params["method"].toUpperCase()=="POST" && params["data"]){
							xmlhttp.setRequestHeader("Content-type",params["dataType"]);
							//console.log(_public.stringify(params["data"]))
							xmlhttp.send(_public.stringify(params["data"]));
						} else xmlhttp.send();
					} catch(e) {
						if (params["error"])
							params["error"](e);
					}
				}
			}
		};
		
		/**
	     * @protected
	     * @alias kb.constructor.iModel
	     * @class
	     */
		//iModels » start
		var iModel = (function(){
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @var
			 * @description
			 	<p>
			 		iModel constructor
			 		<br/>It contains the definer for Model instances
			 	</p>
			 */
			var iModel = function(mType,extension) {
				/**
				 * Definer for iModel constructor's instances
				 * @memberof kb.constructor.iModel.iModel
				 * @var
				 */
				var _obj = function(params){
					Object.defineProperties(this,{
						"index" :{
							configurable: true
							, enumerable: true
							, writable: false
							, value: _obj.index
						}, "list": {
							configurable: true
							, enumerable: true
							, writable: false
							, value: []
						}
					});
					if (params && params.list) this.load(params.list);
					_obj.inst[_obj.index] = this;
					_obj.index++;
					return this;
				};
				_obj.inst = {};
				_obj.index = 0;
				
				_obj.prototype = this;
				Object.defineProperties(_obj.prototype,{
					"type": {
						configurable: false
						, enumerable: true
						, writable: false
						, value: mType
					}
				});
				
				var _objects = _public.clone(iModel.objects);
				_objects[mType] = _obj;
				Object.defineProperty(iModel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				
				_public.extendModel(mType,extension);
				
				return _obj;
			};
			Object.defineProperty(iModel,"objects",{
				configurable: true
				, enumerable: true
				, writable: false
				, value: {}
			});
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @var
			 */
			var _loadList = function(list){
				var _list_prop = _public.clone(_properties["list"]);
				_list_prop.value=(arguments.length==1 && (_public.type(list)=="array"||_public.type(list)=="object")?list:[].slice.call(arguments))||[];
				Object.defineProperty(this,"list",_list_prop);
				Object.defineProperty(this,"templist",_list_prop);
				return this;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @var
			 */
			var _filterList = function(criteria){
				var _templist_prop = _public.clone(_properties["list"])
					, _list = _public.clone(this.list)
					, _list_type = _public.type(_list) 
					, i = _list_type=="array"?_list.length:undefined; 
				;
				
				if (_list_type=="array") {
					while(i--) if (!criteria.call(_list,i)) _list.splice(i,1);
				} else if (_list_type=="object") {
					for (i in _list) {
						if (!criteria.call(_list,i)) delete _list[i];
					}
				}
				_templist_prop.value=_list;
				Object.defineProperty(this,"templist",_templist_prop);
				return this.templist;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @var
			 */
			var _cleanList = function(){
				var _list_prop = _public.clone(_properties["list"]);
				_list_prop.value=[];
				Object.defineProperty(this,"list",_list_prop);
				Object.defineProperty(this,"templist",_list_prop);
				return this;
			};
			
			/**
			 * @protected
			 * @memberof kb.constructor.iModel
			 * @var
			 */
			var _properties = {
				"options": {
					configurable: true
					, enumerable: true
					, writable: true
				}
				, "list": {
					configurable: true
					, enumerable: true
					, writable: false
					, value: []
				}
				, "load": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_loadList)
				}
				, "filter": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_filterList)
				}
				, "clean": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_cleanList)
				}
				, "dump": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_private.dumpInstance(),"Object instance has been already dumped")
				}
			};
			for (prop in _properties) {
				Object.defineProperty(iModel.prototype,prop,_properties[prop]);
				_private.iModelPrototype.push(prop);
			}
			
			return iModel;
		})();
		//iModels » end
		
		/**
	     * @protected
	     * @alias kb.constructor.iPanel
	     * @class
	     */
		//iPanel » start
		var iPanel = (function() {
			var iPanel = function(pType,models,extension) {
				var _obj = function(params){
					var _models = _obj.prototype.models || []
						, i = _models.length
						, _props = {
								"index" :{
									configurable: true
									, enumerable: true
									, writable: false
									, value: _obj.index
								}
								, "models": {
									configurable: true
									, enumerable: true
									, writable: false
									, value: {}
								}
							}
					;
					while(i--) _props.models.value[_models[i]] = new iModel.objects[_models[i]];
					Object.defineProperties(this,_props);
					
					_obj.inst[_obj.index] = this;
					_obj.index++;
					return this;
				};
				_obj.inst = {};
				_obj.index = 0;
				
				_obj.prototype = this;
				Object.defineProperties(_obj.prototype,{
					"type": {
						configurable: false
						, enumerable: true
						, writable: false
						, value: pType
					}
					, "models": {
						configurable: false
						, enumerable: true
						, writable: false
						, value: models
					}
				});
				
				var _objects = _public.clone(iPanel.objects);
				_objects[pType] = _obj;
				Object.defineProperty(iPanel,"objects",_private.getKBObjectDefinition(_objects,{configurable:true}));
				
				_public.extendPanel(pType,extension);
				
				return _obj;
			};
			Object.defineProperty(iPanel,"objects",{
				configurable: true
				, enumerable: true
				, writable: false
				, value: {}
			});
			
			var _properties = {
				"options": {
					configurable: true
					, enumerable: true
					, writable: true
				}
				, "models": {
					configurable: true
					, enumerable: true
					, writable: false
					, value: []
				}
				, "dump": {
					configurable: false
					, enumerable: true
					, writable: false
					, value: _private.wrapInstanceMethod(_private.dumpInstance(),"Object instance has been already dumped")
				}
			};
			for (prop in _properties) {
				Object.defineProperty(iPanel.prototype,prop,_properties[prop]);
				_private.iPanelPrototype.push(prop);
			}
			
			return iPanel;
		})();
		//iPanel » end
		
		//Switch codes below to manage public kb properties one at the time
		for (var key in _public) Object.defineProperty(_self,key,_private.getKBObjectDefinition(_public[key]));
		/*Object.defineProperties(_self,{
			"clone": _private.getKBObjectDefinition(_public.clone)
			, "extend": _private.getKBObjectDefinition(_public.extend)
			, "stringify": _private.getKBObjectDefinition(_public.stringify)
			, "type": _private.getKBObjectDefinition(_public.type)
			, "setModel": _private.getKBObjectDefinition(_public.setModel)
			, "getModel": _private.getKBObjectDefinition(_public.getModel)
			, "stopModel": _private.getKBObjectDefinition(_public.dumpModel)
			, "setPanel": _private.getKBObjectDefinition(_public.setPanel)
			, "getPanel": _private.getKBObjectDefinition(_public.getPanel)
			, "stopPanel": _private.getKBObjectDefinition(_public.dumpPanel)
			, "loadFile": _private.getKBObjectDefinition(_public.loadFile)
		});*/
		
		return _self;
	}
)();